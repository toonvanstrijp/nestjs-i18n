import * as ts from 'typescript';

const convertArrayItemToType = async (item: any): Promise<ts.TypeNode> => {
  if (Array.isArray(item)) {
    const nestedArrayItemTypes = await Promise.all(
      item.map((nestedItem) => convertArrayItemToType(nestedItem)),
    );
    return ts.factory.createTupleTypeNode(nestedArrayItemTypes);
  }
  if (typeof item === 'object') {
    return ts.factory.createTypeLiteralNode(
      await convertObjectToTypeDefinition(item),
    );
  }
  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
};

export const convertObjectToTypeDefinition = async (
  object: any,
): Promise<ts.TypeElement[]> => {
  switch (typeof object) {
    case 'object':
      return Promise.all(
        Object.keys(object).map(async (key) => {
          const value = object[key];

          if (typeof value === 'string') {
            return ts.factory.createPropertySignature(
              undefined,
              ts.factory.createStringLiteral(key),
              undefined,
              ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
            );
          }
          if (Array.isArray(value)) {
            const arrayItemTypes = await Promise.all(
              value.map((item) => convertArrayItemToType(item)),
            );
            return ts.factory.createPropertySignature(
              undefined,
              ts.factory.createStringLiteral(key),
              undefined,
              ts.factory.createTupleTypeNode(arrayItemTypes),
            );
          }
          return ts.factory.createPropertySignature(
            undefined,
            ts.factory.createStringLiteral(key),
            undefined,
            ts.factory.createTypeLiteralNode(
              await convertObjectToTypeDefinition(value),
            ),
          );
        }),
      );
  }

  return [];
};

const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

export const createTypesFile = async (object: any) => {
  const sourceFile = ts.createSourceFile(
    'placeholder.ts',
    '',
    ts.ScriptTarget.ESNext,
    true,
    ts.ScriptKind.TS,
  );

  const i18nTranslationsType = ts.factory.createTypeAliasDeclaration(
    [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
    ts.factory.createIdentifier('I18nTranslations'),
    undefined,
    ts.factory.createTypeLiteralNode(
      await convertObjectToTypeDefinition(object),
    ),
  );

  const nodes = ts.factory.createNodeArray([
    ts.factory.createImportDeclaration(
      undefined,
      ts.factory.createImportClause(
        true,
        undefined,
        ts.factory.createNamedImports([
          ts.factory.createImportSpecifier(
            false,
            undefined,
            ts.factory.createIdentifier('Path'),
          ),
        ]),
      ),
      ts.factory.createStringLiteral('nestjs-i18n'),
      undefined,
    ),
    i18nTranslationsType,
    ts.factory.createTypeAliasDeclaration(
      [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      ts.factory.createIdentifier('I18nPath'),
      undefined,
      ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('Path'), [
        ts.factory.createTypeReferenceNode(
          ts.factory.createIdentifier('I18nTranslations'),
          undefined,
        ),
      ]),
    ),
  ]);

  nodes.forEach((node) => {
    ts.addSyntheticLeadingComment(
      node,
      ts.SyntaxKind.MultiLineCommentTrivia,
      ' prettier-ignore ',
      true,
    );
  });

  return printer.printList(ts.ListFormat.MultiLine, nodes, sourceFile);
};

export const annotateSourceCode = (code: string) => {
  return `/* DO NOT EDIT, file generated by nestjs-i18n */

/* eslint-disable */
${code}`;
};
